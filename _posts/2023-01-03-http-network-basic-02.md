---
layout: post
title: "그림으로 배우는 Http & Network Basic 제2장"
date: 2023-01-03 10:03:37 +0530
categories: Book Network
---

책을 읽고 정리합니다.

## 제2장 간단한 프로토콜 HTTP

### HTTP는 클라이언트와 서버 간에 통신을 한다

HTTP는 클라이언트와 서버의 역할을 명확하게 구분한다.

- 클라이언트: 텍스트와 이미지 등 리소스가 필요하다고 요구하는 쪽
- 서버: 리소스를 제공하는 쪽

### 리퀘스트와 리스폰스를 교환하여 성립

HTTP는 `1. 클라이언트로부터 리퀘스트(요청, Request)가 송신`되며, 그 결과 `2. 서버로부터 리스폰스(응답, Response)가 되돌아`온다.

```
# 클라이언트가 HTTP 서버에 송신한 리퀘스트 내용
GET /index.html HTTP /1.1
Host: www.hackr.jp
```

- "GET"은 서버에 요구하는 종류, `메소드`
- "/index.html"은 요구 대상인 리소스, `리퀘스트 URI`
- "HTTP/1.1"은 클라이언트 기능을 식별하기 위한 `HTTP 버전 번호`

즉, HTTP 서버 상에 있는 "/index.html"라는 리소스가 필요하다는 리퀘스트이다.

![IMG_0344](https://user-images.githubusercontent.com/68533016/210318796-670bc541-4f13-4cfb-a87e-8e15887316c4.jpg){: width="700" }

```
# 서버의 리스폰스 내용
HTTP /1.1 200 OK
Date: Tue, 10 Jul 2012 06:50:15 GMT
Content-Length: 362
Content-Type: text/html

<html>
```

- "HTTP /1.1"은 `서버의 HTTP 버전`
- "200 OK"는 `리퀘스트의 처리 결과를 나타내는 상태 코드와 설명`
- 다음 줄은 리스폰스가 발생한 일시를 나타내고 있는데 `헤더 필드`라고 불리는 것 중 하나
- 빈 줄로 구분하여 그 아래 있는 부분이 `바디(body)`라 불리는 리소스 본체

![IMG_0345](https://user-images.githubusercontent.com/68533016/210318783-c40629f8-8866-4ac3-9621-fcf25643823b.jpg){: width="700" }aa

### HTTP는 상태를 유지하지 않는 프로토콜

HTTP는 `상태를 계속 유지하지 않는` 스테이트리스(stateless) 프로토콜이다. 결국, 이전에 보냈던 리퀘스트나 이미 되돌려준 리스폰스에 대해서는 전혀 기억하지 않는다.

이는 많은 데이터를 매우 빠르고 확실하게 처리하는 `범위성(scalability)`를 확보하기 위해 **간단하게 설계**되어 있는 것이다.

상태를 유지하지 않는다는 점에서 서버의 CPU나 메모리 같은 리소스의 소비를 억제할 수 있다.

### 메소드를 사용해 지시를 내리다

`메소드` 명령으로 리퀘스트 URI로 지정한 리소스에 어떤 행동을 하기 원하는지 리퀘스트를 보낸다.

| 메소드  | 설명                         |
| ------- | ---------------------------- |
| GET     | 리소스 취득                  |
| POST    | 엔티티 바디 전송             |
| PUT     | 파일 전송                    |
| HEAD    | 메시지 헤더 취득             |
| DELETE  | 파일 삭제                    |
| OPTIONS | 서프트하고 있는 메소드 문의  |
| TRACE   | 경로 조사                    |
| CONNECT | 프록시에의 터널링 요구       |
| LINK    | 리소스 간에 링크 관계를 확립 |
| UNLINK  | 링크 관계 삭제               |

### 지속 연결로 접속량을 절약

HTTP가 널리 보급됨에 따라 다량의 이미지를 포함한 문서 등이 늘어났다. 그렇기 때문에 리퀘스트를 보낼 때마다 매번 TCP 연결과 종료를 하게 되는 쓸모없는 일이 발생되어 통신량이 늘어나게 된다.

#### 지속 연결

HTTP/1.1과 일부 HTTP/1.0에서는 TCP 연결 문제를 해결하기 위해 `지속 연결(Persistent Connections)`라는 방법을 고안했다.
**어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지**한다.

지속 연결을 하는 이점

- TCP 커넥션의 연결과 종료를 반복하는 오버헤드를 줄여주기 때문에 서버에 대한 부하 경감
- 오버헤드를 줄인 만큼 HTTP 리퀘스트와 리스폰스가 빠르게 완료되기 때문에 웹 페이지를 빨리 표시할 수 있음

#### 파이프라인화

`파이프라인화`에 의해서 이전에는 리퀘스트 송신 후에 리스폰스를 수신할 때까지 기다린 뒤에 리퀘스트를 발행하던 것을, `리스폰스를 기다리지 않고` 바로 다음 리퀘스트를 보낼 수 있다.

#### 속도

(느림) 개별 연결 < 지속 연결 < 파이프라인화 (빠름)

### 쿠키를 사용한 상태 관리

HTTP는 stateless 프로토콜이기 때문에 과거에 교환했던 리퀘스트와 리스폰스 상태를 알 수 없다.

하지만, 인증이 필요한 웹 페이지의 경우 상태 관리를 하지 않는다면 새로운 페이지로 이동할 때마다 로그인을 해야하는 불편함이 생긴다.

이와 같은 문제를 해결하기 위해 `쿠키`라는 시스템이 도입되었다. 쿠키는 `리퀘스트와 리스폰스에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하기 위한 시스템`이다.

- 쿠키를 가지지 않은 상태에서의 리퀘스트
  - 1)클라이언트: 리퀘스트 송신
  - 서버: 쿠키 발행, 누구에게 무엇을 전달했는지 기억
  - 2)서버: 리스폰스에 쿠키를 붙여서 송신
- 2회째 이후(쿠키를 가지고 있는 상태)의 리퀘스트
  - 3)클라이언트: 리퀘스으에 쿠키를 붙여서 송신
  - 4)서버: 쿠키 확인, 리스폰스

## Reference

- [그림으로 배우는 Http & Network Basic](http://www.yes24.com/Product/Goods/15894097)
